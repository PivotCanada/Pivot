{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useState } from \"react\"; // NOTE : Generate Blank Errors Object ...\n\nconst createErrors = initialValues => {\n  let errors = {};\n\n  for (var key in initialValues) {\n    errors[key] = \"\";\n  }\n\n  return errors;\n};\n\nexport const useForm = initialValues => {\n  const {\n    0: values,\n    1: setValues\n  } = useState(initialValues);\n  const {\n    0: errors,\n    1: setErrors\n  } = useState(createErrors(initialValues));\n  const {\n    0: step,\n    1: setStep\n  } = useState(1);\n  const {\n    0: submitting,\n    1: setSubmitting\n  } = useState(false);\n\n  const handleChange = e => {\n    setValues(_objectSpread(_objectSpread({}, values), {}, {\n      [e.target.name]: e.target.value\n    }));\n  };\n\n  const handleDirectChange = (name, value) => {\n    setValues(_objectSpread(_objectSpread({}, values), {}, {\n      [name]: value\n    }));\n  }; // NOTE : Wrap handleErrors function in async, to await data fetches, such as verfiying user does not exist, etc ...\n\n\n  const handleErrors = async (values, validation) => {\n    const {\n      errors,\n      valid\n    } = await validation(values);\n    setErrors(errors);\n    return valid;\n  };\n\n  return {\n    values,\n    step,\n    errors,\n    submitting,\n    setStep,\n    handleChange,\n    handleDirectChange,\n    handleErrors,\n    setSubmitting\n  };\n};","map":{"version":3,"sources":["/Users/dalyanparker/Programming/Applications/pivot-front-end/hooks/useForm.js"],"names":["useState","createErrors","initialValues","errors","key","useForm","values","setValues","setErrors","step","setStep","submitting","setSubmitting","handleChange","e","target","name","value","handleDirectChange","handleErrors","validation","valid"],"mappings":";;;;;;AAAA,SAASA,QAAT,QAAyB,OAAzB,C,CAEA;;AAEA,MAAMC,YAAY,GAAIC,aAAD,IAAmB;AACtC,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIC,GAAT,IAAgBF,aAAhB,EAA+B;AAC7BC,IAAAA,MAAM,CAACC,GAAD,CAAN,GAAc,EAAd;AACD;;AACD,SAAOD,MAAP;AACD,CAND;;AAQA,OAAO,MAAME,OAAO,GAAIH,aAAD,IAAmB;AACxC,QAAM;AAAA,OAACI,MAAD;AAAA,OAASC;AAAT,MAAsBP,QAAQ,CAACE,aAAD,CAApC;AACA,QAAM;AAAA,OAACC,MAAD;AAAA,OAASK;AAAT,MAAsBR,QAAQ,CAACC,YAAY,CAACC,aAAD,CAAb,CAApC;AACA,QAAM;AAAA,OAACO,IAAD;AAAA,OAAOC;AAAP,MAAkBV,QAAQ,CAAC,CAAD,CAAhC;AACA,QAAM;AAAA,OAACW,UAAD;AAAA,OAAaC;AAAb,MAA8BZ,QAAQ,CAAC,KAAD,CAA5C;;AAEA,QAAMa,YAAY,GAAIC,CAAD,IAAO;AAC1BP,IAAAA,SAAS,iCACJD,MADI;AAEP,OAACQ,CAAC,CAACC,MAAF,CAASC,IAAV,GAAiBF,CAAC,CAACC,MAAF,CAASE;AAFnB,OAAT;AAID,GALD;;AAOA,QAAMC,kBAAkB,GAAG,CAACF,IAAD,EAAOC,KAAP,KAAiB;AAC1CV,IAAAA,SAAS,iCACJD,MADI;AAEP,OAACU,IAAD,GAAQC;AAFD,OAAT;AAID,GALD,CAbwC,CAoBxC;;;AACA,QAAME,YAAY,GAAG,OAAOb,MAAP,EAAec,UAAf,KAA8B;AACjD,UAAM;AAAEjB,MAAAA,MAAF;AAAUkB,MAAAA;AAAV,QAAoB,MAAMD,UAAU,CAACd,MAAD,CAA1C;AACAE,IAAAA,SAAS,CAACL,MAAD,CAAT;AACA,WAAOkB,KAAP;AACD,GAJD;;AAMA,SAAO;AACLf,IAAAA,MADK;AAELG,IAAAA,IAFK;AAGLN,IAAAA,MAHK;AAILQ,IAAAA,UAJK;AAKLD,IAAAA,OALK;AAMLG,IAAAA,YANK;AAOLK,IAAAA,kBAPK;AAQLC,IAAAA,YARK;AASLP,IAAAA;AATK,GAAP;AAWD,CAtCM","sourcesContent":["import { useState } from \"react\";\n\n// NOTE : Generate Blank Errors Object ...\n\nconst createErrors = (initialValues) => {\n  let errors = {};\n  for (var key in initialValues) {\n    errors[key] = \"\";\n  }\n  return errors;\n};\n\nexport const useForm = (initialValues) => {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState(createErrors(initialValues));\n  const [step, setStep] = useState(1);\n  const [submitting, setSubmitting] = useState(false);\n\n  const handleChange = (e) => {\n    setValues({\n      ...values,\n      [e.target.name]: e.target.value,\n    });\n  };\n\n  const handleDirectChange = (name, value) => {\n    setValues({\n      ...values,\n      [name]: value,\n    });\n  };\n\n  // NOTE : Wrap handleErrors function in async, to await data fetches, such as verfiying user does not exist, etc ...\n  const handleErrors = async (values, validation) => {\n    const { errors, valid } = await validation(values);\n    setErrors(errors);\n    return valid;\n  };\n\n  return {\n    values,\n    step,\n    errors,\n    submitting,\n    setStep,\n    handleChange,\n    handleDirectChange,\n    handleErrors,\n    setSubmitting,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}